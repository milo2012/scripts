import socket
import struct
import argparse
import ipaddress
import sys
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from ntlm_auth.ntlm import NtlmContext
import warnings

# Suppress cryptography deprecation warnings
try:
    from cryptography.utils import CryptographyDeprecationWarning
    warnings.filterwarnings("ignore", category=CryptographyDeprecationWarning)
except ImportError:
    warnings.filterwarnings("ignore", category=DeprecationWarning)

# MS-NNS Protocol Constants
MESSAGE_TYPE_HANDSHAKE = 0x16

def create_nns_message(message_type, payload):
    version = 0x0301
    length = len(payload)
    return struct.pack('!BHH', message_type, version, length) + payload

def parse_nns_message(data):
    if len(data) < 5:
        return None, None, None
    message_type, version, length = struct.unpack('!BHH', data[:5])
    if len(data) < 5 + length:
        return None, None, None
    payload = data[5:5+length]
    return message_type, version, payload

def parse_ip_target_line(line, default_port):
    """Parse a single line of IP or IP:PORT"""
    line = line.strip()
    if not line or line.startswith('#'):
        return []

    ip_port_list = []

    if ':' in line:
        ip_part, port_part = line.rsplit(':', 1)
        try:
            port = int(port_part)
        except ValueError:
            port = default_port
    else:
        ip_part = line
        port = default_port

    # Handle IP, CIDR, or range
    try:
        ip = ipaddress.ip_address(ip_part)
        ip_port_list.append((str(ip), port))
    except ValueError:
        try:
            network = ipaddress.ip_network(ip_part, strict=False)
            ip_port_list.extend([(str(ip), port) for ip in network.hosts()])
        except ValueError:
            if '-' in ip_part:
                try:
                    base_ip, end_range = ip_part.rsplit('-', 1)
                    base_parts = base_ip.split('.')
                    if len(base_parts) == 4:
                        for i in range(int(base_parts[3]), int(end_range)+1):
                            ip_port_list.append(('.'.join(base_parts[:3] + [str(i)]), port))
                except:
                    pass
    return ip_port_list

def load_targets_from_file(filename, default_port):
    ips_ports = []
    try:
        with open(filename, 'r') as f:
            for line in f:
                ips_ports.extend(parse_ip_target_line(line, default_port))
    except Exception as e:
        print(f"Error reading file '{filename}': {e}")
        sys.exit(1)
    return ips_ports

def test_ntlm_auth(server_ip, server_port, timeout=3):
    result = {
        'ip': server_ip,
        'port': server_port,
        'port_open': False,
        'authenticated': False,
        'null_auth': True,
        'status': 'UNKNOWN',
        'error_detail': None
    }

    # Check if port is open
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((server_ip, server_port))
        result['port_open'] = True
    except (socket.timeout, ConnectionRefusedError) as e:
        result['status'] = 'PORT CLOSED'
        result['error_detail'] = str(e)
        return result
    except Exception as e:
        result['status'] = 'ERROR'
        result['error_detail'] = str(e)
        return result

    # Port is open, attempt NTLM auth (null credentials)
    try:
        ntlm_context = NtlmContext(username="", password="", domain="", workstation=None, cbt_data=None)
        negotiate_msg = ntlm_context.step()
        s.send(create_nns_message(MESSAGE_TYPE_HANDSHAKE, negotiate_msg))

        response_data = s.recv(4096)
        if response_data:
            _, _, challenge_payload = parse_nns_message(response_data)
            if challenge_payload:
                auth_msg = ntlm_context.step(challenge_payload)
                s.send(create_nns_message(MESSAGE_TYPE_HANDSHAKE, auth_msg))
                result['authenticated'] = True
                result['status'] = 'SUCCESS'
            else:
                result['status'] = 'FAILED'
        else:
            result['status'] = 'FAILED'
    except Exception as e:
        result['status'] = 'FAILED'
        result['error_detail'] = str(e)
    finally:
        s.close()

    return result

def print_result(result, quiet=False):
    """One-line output; only SUCCESS is colored"""
    if quiet and not result['authenticated']:
        return

    GREEN = "\033[92m"
    RESET = "\033[0m"

    if result['status'] == 'SUCCESS':
        auth_type = "NULL AUTH" if result['null_auth'] else "CREDENTIALS"
        print(f"{GREEN}{result['ip']}:{result['port']} - SUCCESS [{auth_type}]{RESET}")
    elif result['status'] == 'PORT CLOSED':
        print(f"{result['ip']}:{result['port']} - PORT CLOSED ({result.get('error_detail')})")
    elif result['status'] == 'FAILED':
        print(f"{result['ip']}:{result['port']} - FAILED (port open={result['port_open']}, detail={result.get('error_detail')})")
    else:
        print(f"{result['ip']}:{result['port']} - {result['status']} ({result.get('error_detail')})")

def main():
    parser = argparse.ArgumentParser(description="NTLM-over-TCP Null Auth Scanner")
    target_group = parser.add_mutually_exclusive_group(required=True)
    target_group.add_argument('target', nargs='?', help='IP address, CIDR range, or IP range')
    target_group.add_argument('-f', '--file', help='File containing list of IPs or IP:PORT')
    parser.add_argument('-p', '--port', type=int, default=9380, help='Default port if not specified in file')
    parser.add_argument('-t', '--timeout', type=int, default=5, help='Timeout seconds')
    parser.add_argument('--threads', type=int, default=10, help='Number of threads')
    parser.add_argument('--no-banner', action='store_true', help='Suppress banner')
    parser.add_argument('--quiet', action='store_true', help='Only show successful authentications')
    args = parser.parse_args()

    if not args.no_banner:
        print("NTLM-over-TCP Null Auth Scanner\n" + "="*50 + "\n")

    target_list = []
    if args.file:
        target_list = load_targets_from_file(args.file, args.port)
    else:
        target_list = parse_ip_target_line(args.target, args.port)

    if not target_list:
        print("No valid targets found")
        sys.exit(1)

    successful, failed = [], []

    with ThreadPoolExecutor(max_workers=args.threads) as executor:
        future_to_ip = {executor.submit(test_ntlm_auth, ip, port, args.timeout): (ip, port) for ip, port in target_list}
        for future in as_completed(future_to_ip):
            result = future.result()
            print_result(result, quiet=args.quiet)
            (successful if result['authenticated'] else failed).append(result)

    '''
    if not args.quiet:
        print("="*50)
        print(f"Summary: {len(successful)} successful, {len(failed)} failed")
    '''

if __name__ == "__main__":
    main()
